# Simple JavaScript Mapping

## title slide

Welcome everyone, and thanks for coming. My name’s Moacir de Sá Pereira, and
I’ll be leading you in today’s workshop. Here’s my twitter name and the
hashtag for this year’s NYCDH DH Week, and I’d like to thank the organizers
for finding time for this workshop and the NYU Data Services team for
providing the space.

## Final map

Today, in this short time, we’re going to build a simple map in JavaScript
that highlights a few geographic points mentioned in Langston Hughes’s poem
“Could Be.” The map will look something like this. I didn’t know this poem
until Alba Newmann Holmes presented a paper, “‘Could Be’: Langston Hughes as
Situationist Cartographer,” at a special session I convened at the MLA
Convention in 2015. It’s a good poem to map, because there are a few specific
places mentioned and because it, even in its brevity, demonstrates a few
fundamental issues with making maps.

## Get the Files

Before we go any further, though, let’s download the files we’ll be using for
this course. Please go to this url and download the zip file and unzip it to
your computer’s desktop.

## File list

When you unzip the zipfile, you should have a folder that looks something like
this. The icons may look a bit different, but the point is that there are two
folders and three files. 

Now, even though we talk about a webpage, as though it’s a single thing, what
you see in your browser is typically generated by processes that rely on
several files, which you see here.

## Website structure

One way to think of a website is as a sentence, made up of parts of speech.
The html file contains the basic semantic building blocks of the page,
including metadata about it and instructions to put a box of content here or a
map there or a paragraph there.

CSS, or stylesheets, are the adjectives. They explain how those building
blocks should look. What size the text should be, what color the background
should be, what the margins should be, and so on. We’ll barely touch CSS
today.

Finally, there’s JavaScript. JavaScript is the verbs. The process. The
movement. Anything on a website that involves motion or reaction is likely a
JavaScript process, like “draw a map” or “zoom in” or “change the color.”
Similarly, and in true autopoetic fashion, JavaScript can create html and css.

## Index.html

But it all starts with html, so open up the index.html file in a text editor.
(lead through text editor opening)

There is quite a bit going on in these 19 lines, but they should indicate both
the general structure and syntax of an html file and, hence, a webpage. 

Note that there is a head and a body. The head includes metadata about the
page, like what its title is, but it also tells the browser where to look for
css files here. Here, we’re downloading two. One is the Bootstrap css file
from a server on the internet, and the other is just the “styles.css” file
that’s on your computer. Bootstrap provides a set of templates that help make
your page look nice quickly

Then, in the body, we see a div, which is an arbitrary block, and that div has
two elements inside it, another div with an id of “response” and a heading,
the h1 tag. The h1 and the response div then also have some text inside them.

At the bottom of the body, you see a handful of script tags. Like the css in
the header, these indicate to the browser where to go looking for javascript.
The first file is JQuery, which is a set of functions that help make dynamic
webpages. The next two are related to bootstrap, and the last, “sandbox.js,”
is the local file on your computer. We’ll spend the next hour with that file.

## Webpage

Now if you were to open index.html in a browser with JavaScript disabled, it would
look something like this, where all you see is the text that you saw in
index.html.

## jsed index.html

However, if you do actually open it in your browser, which you can do by
double clicking on index.html, you’ll see that there is different text under
the header. Somehow, the JavaScript is manipulating the html and changing the
text and coloring the background.

So let’s open sandbox.js and see what is happening.

## sandbox.js

We’ll go into more detail about the top and bottom lines of this file, but you
can ignore them for now. Briefly, they instruct the browser to wait a second
and then change the text of the div with the id of “response” and color it
green. What we’re interested in is the text itself.

So change that line of “This text is coming from JavaScript” to something
else, save the JavaScript file, and reload the webpage. Your change should now
appear. 

Note the syntax, however. There’s the keyword “return”, then the text in
double quotes, and then a semicolon. That’s a complete statement, and
statements end with semicolons in JavaScript.

If it didn’t work, make sure that you surrounded your text with quotes and
make sure your text editor isn’t converting quotes to smart quotes. (lead
changing textedit to not make smart quotes)

Once it works, pat yourself on the back. You are now a JavaScript programmer.

## types

Putting text in double quotes creates a “string,” which is a piece of data
JavaScript recognizes. Two other basic ones are numbers, which are just
numbers without double quotes, and booleans, which are either true or false,
again, without quotes.

Change line 6 of sandbox.js to perform some math, like noted here. Save and
reload your webpage, and you should now have a clumsy calculator.

## Variables

Programming as such becomes more powerful once you can start saving time by
using variables. The examples here don’t actually do that, but they
illustrate the process of defining variables and assigning values to them.

You define a variable with the “let” keyword, then name the variable, then add
an equal sign, the value, and a semicolon. From the “let result” line,
however, you can see that you can evaluate values when assigning them to a
variable. And then the variable can be reused later, like in the return line.

Just like a baby’s first steps are clumsy and inefficient, so is the coding,
but the goal is to see how these things work first.

## Three more types

There are three more types to talk about that are more complex, because they
interact with the previous data types.

Arrays are lists of data. Every item in an array can be a string, a number, or
even another array. The items are separated by commas and enclosed in
brackets.

Objects have properties. In this example, the object is indicated with curly
braces and has two properties, a name property and an age property. A string
is assigned to the name property, and a number is assigned to the age
property.

Functions are where the action happens. If JavaScript is the verbs of a
webpage, functions are the verbs of JavaScript. In fact, in sandbox.js, if you
look again, you’ll see that the top and bottom lines are chains of functions,
and what you’re typing with “return” is inside a function. “Return,” actually,
is the keyword that tells a function to stop and send a value, the return
value, back to whatever called the function. We’ll discuss this in a bit more
detail in a few slides.

## Arrays

Arrays are lists of data. As mentioned, the data can be any type. The way you
access a specific member of an array is by using its index value, which is
what order it’s in in the list. Surprisingly, the first item’s index is zero,
the second’s is one, and so on. This is confusing, so I tend to talk about
zeroth, oneth, twoth, and threeth values of an array. 

Once you assign an array to a variable, you can call a specific member by
using the index number associated with that member in brackets, like in this
example. Create your own array and have your webpage return a specific member
from the array.

## Objects

Objects are have properties. That’s about all there is to them. You access the
properties using dot notation, as noted here. Properties can be any data type,
strings, numbers, arrays, or other objects. But when a property is a function,
it’s called a method. There are two methods in your sandbox.js file, dot html
and dot add class. They are both methods belonging to a javascript object that
represents the bit of html code that creates the response div.

This is purposely vague and indistinct, because so are objects. They can
contain any kind of property you can dream up. Create an object of your own
with some properties and access them in your sandbox.js file.

## Functions

Finally, there are functions. This section is very short because it is hard to
use functions with the way the sandbox.js file is set up. But you can see what
their basic syntax is here: the keyword function, followed by parentheses.
Inside the parentheses you can define parameters that are passed into the
function. These are variables that are available inside the function to work
with. In this example, we’re not using any, so we keep that blank. Then there
are braces holding the logic of the function, in this case that’s just the
return statement.

But one way to see how functions work is by looking at the sandbox file a bit
differently

## sandbox.js, exploded

I’ll go through this line by line. In the first line, we call the function set
timeout, which takes two parameters, a function, and a time, which basically
tells the browser to run the function after the time has elapsed. We see the
time as the last bit of information on the bottom here, which means that
everything in between is the function that is supposed to run after 1000
milliseconds, or one second.

Now this function calls a function, called dollar sign. This is shorthand for
jQuery, which means that we’re running a jQuery function and passing it a
parameter, in this case a string of poundsign response. The jQuery function is
telling the browser to grab the chunk of html with an id of “response.”

Now that we have that chunk of html, it’s a javascript object, which means it
has properties--or methods. The first method is on the next line, html.
The html method takes a function and changes the content of the html that
jQuery grabbed, so we invoke another function. Then that function returns
another function that returns the string “functions inside functions”

Then we execute another method on that chunk of html, this time the addclass
method, which adds some classes to the html, which we pass as a string.
Classes help style the html, and the alert and alert-success classes are what
make the text get a green background.

Finally, at the end, we have the time, again.

This is very confusing. It’s a very weird way to think of causality. What we
think of as step-by-step instructions (wait a second, get the html, change the
text, change the color) aren’t a list of commands, but, rather, are functions
and methods embedded inside one another. We won’t be writing anything this
complex today, but it’s useful to try and start thinking nestedly in this way.

## Leaflet

That’s a reasonable intro to javascript for a two-hour workshop. And the funny
thing is, you’ve learned most of the fundamental aspects of the language. The
rest just builds on the six data types and how they interact with each other
using conditional statements or loops. 

So to build on this basic knowledge we’ll move to leaflet. Leaflet is a set of
methods that work on a Leaflet object that draw a map and let users interact
with it. It’s surprisingly powerful for how basic it is, and though there are
mapping solutions for online that are easier, like google maps and carto, none
offers you the chance to get close to your data by manipulating it in
JavaScript.

## could-be/index.html

For this part of the workshop, we’re switching from the files at the root of
the directory to the files inside the could-be folder. If you open the
index.html inside the could-be folder in your text editor, you’ll see that
it’s more or less the same as the earlier index.html file. It’s loading an
extra style sheet in the head, and there are a few more script tags at the
bottom, loading leaflet from the internet and two files from your computer,
could-be and data.js.

More notably, the response div is missing. Instead, there are two new divs.
One is called map and the other is called poem. But both are empty.

## index in the browser

If you double click on index.html and open it in your browser, however, you
see that the page isn’t mostly blank. There’s a poem there. How did it get
there? The answer is, of course, through JavaScript, in much the same way
we’ve been doing so far in this workshop. But the details for that are saved
for later. Instead, we want to do something with that big white expanse above
the poem. Namely, we want it to be a map.

## could-be/could-be.js

If you open the could-be.js file in your text editor, you'll see that there's
already quite a bit there, but it's all commented out. As a first step, delete
the top line (a slash and an asterisk) and the last line, an asterisk and a
slash.

## uncommented could-be.js

Once the file is uncommented, you can save and reload the page in your
browser. A map should now load showing Washington Square Park. So let’s go
over every line of javascript here.

First, we define a variable map and assign it to the return value of the map
method for the L object. L is a variable that stands for Leaflet. It gets
loaded when we added that line about leaflet to the index.html. L has many
methods, and one of the is map, which defines a map based on the name of the
div you pass it, which in this case is, again, map. So, in short, this line
takes the div with an id map and turns it into a Leaflet map, while also
creating a variable we can use from then on, also called map, to manipulate
what we’ve got on the page.

The second line uses the tileLayer method to define a tile layer with some
properties. This is the background of the map, the part with all the streets
and water. Then at the end, we use the addTo method to add this layer to the
map variable. Without that add to, we’d just have a blank gray square here.

The next statement defines a variable nyu and assigns to it an array. In this
case, the zeroth element of the array is the latitude, and the oneth element
is the longitude.

Finally, we use the setview method that map inherited when it became a Leaflet
map, to center the map at the nyu latitude and longitude, and we set the zoom
level to 14.

Yes! that’s a lot! But these are just the initial conditions of the map. You
set the tile layer once and forget it. You set the center and zoomlevel once
and forget it. After all, it’s easy to change both the center and zoom level
with just a mouse click or two.

## Drawing a marker

Leaflet lets us draw markers, lines, and polygons. It also lets us attach
popups to those items, so let’s draw one of each just for fun

For the circleMarker, we reuse the nyu variable.

For the line--or polyline--it’s just an array of arrays, where each subarray is a latitude
and longitude. Since nyu is an array, it works great as the first point in the
line.

A polygon is the same as a polyline, except leaflet fills it in.

But the fundamentals are still here. We’re using three methods the L object
has, passing them arrays as parameters, and then using the addto method to add
them to the map.

You can use any coordinates you like and zoom out as appropriate, but these
are the basics.

## my map

Here’s what my marker, polyline, and polygon look like

## Could Be

Now let’s take a closer look at the poem, which is from 1949. We see that
there are five different places mentioned in the poem, and two are mentioned
twice. Do any of you recognize any of the places?

I hunted down all five, and it was kind of tricky to find two, Hastings St.
and Fifth and Mound. This is because they no longer exist like they used to.
They were once the centers of African-American communities in Detroit and
Cincinnati, respectively, but both were bulldozed away to make room for I-75. 

Let’s put a dot on the map for all five of these locations then. Open up
could-be/data.js in your text editor.

## data.js

Now I’ve collected the coordinates for all five places already and put them in
data.js. You don’t have to edit anything, but I want you to see what is at the
top of this file. As you can see, I define a variable, points, and assign to
it an array. Now each element of the array is an object, and each object has
three properties, a coords property, a name propoerty, and a mentions
property.

The coords property is just like the nyu variable from could-be.js. It’s an
array with a latitude and a longitude. The name is the name, and the mentions
refers to how many times the place is mentioned in the poem.

Because this file is loaded before the could-be.js file, this points variable
is available to us inside could-be.js, so now we can get fancy.

## Looping

How can we get those five points on the map? We know how to do it once, but
what about for five times? Wouldn’t it be nice if we could loop over the array
and, with every time through, pick up a new set of coordinates and add it to
the map? Yes, and, in fact, that’s exactly what we’ll do.

Arrays have a method called “forEach,” which lets you write a function that
manipulates every item in the array at a time. That item is named using the
parameter you assign to the forEach function. So in this example, it’s
“location.” That means that every time the forEach steps through the points
array, it creates a variable, called location, and assigns that object to the
variable. 

So the first time through, location is equal to the object that has the
hastings street name property. The second time, it’s the object with the lenox
avenue property, and so on, until the last time through, it’s the rampart
property.

With just three lines of code, we’ve added five dots to the map. Now the value
of looping starts to make sense, I hope.

## Fitting the bounds

However, the map is still zoomed in on NYU. We want to see the entire
lower-48. In leaflet, the map object has a method, fit bounds, that lets you
draw a box around how much of the map you want to have visible.

## binding a popup

We can do even better. Circlemarkers have a method associated with them,
called bind popup, that lets us define what the popup for the marker is. Since
each object in the points array has a name property, let’s make a popup for
each marker with the place’s name in it.

Change the could-be.js file a bit, save, and reload the webpage. Zoom out and
you see all five points and if you click on one, the popup shows up.

## changing options

Even better, let’s change the color of the markers. Circle markers, polylines,
and polygons actually take two parameters. The first is the coordinates, like
we’ve done so far. The second is an object with properties that define the
style of the circlemarker or polyline or polygon.

In Leaflet, the color property refers to the outline, or stroke color, and the
fillcolor property refers to the shading inside the circle marker or polygon.
I picked green here, but you can use any hex value for a color too (explain
hex values).

But also, you may notice that I don’t use green as a string in the options
object. Instead, I define a variable, color, and use it. The reason for that
is that it’ll make things easier when I want to color the markers differently
depending on how many times each place is mentioned.

## Conditionals

Earlier, I said that looping and conditionals were most of what was missing
from this introduction to javascript. By putting the five dots on the map,
we’ve used a loop, specifically a foreach loop on an array. Now for
conditionals. They test whether a statement is true or false--those boolean
values I introduced at the beginning of the workshop but haven’t yet used. If
the statement evaluates to true, a conditional does one thing. Otherwise, it
does another.

Now notice what happens here. First, we define the variable color, but we
don’t assign it a value. Next, we start a conditional through an if statement.
These triple equals signs basically make this statement mean “if it is the
case that the value of location.mentions is exactly 2, do something.” This
time around, that something is assigning the value green to color. Then we
follow up with an else clause that says what to do when the value of
location.mentions is not exactly 2, which is to assign the value red to color.

It repeats this process with every location, so we end up with two green
circle markers and three red ones, just as we would expect.

So save and reload.

## Complete 

And the map should be complete! 

## For more

Now with the remaining time, I can answer questions, but one clear one could
be “how do you know what methods a leaflet map object or something else has?”
That’s where it’s useful to read the documentation. I keep relooking up these
things myself. Programming is very picky and precise, but it’s also very open
responding to your creativity.

## Thanks

Thanks!
